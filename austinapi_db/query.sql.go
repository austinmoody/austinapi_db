// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package austinapi_db

import (
	"context"
	"time"
)

const getHeartRate = `-- name: GetHeartRate :many
SELECT id, date, high, low, average, created_timestamp, updated_timestamp
FROM heartrate
WHERE id = $1
`

func (q *Queries) GetHeartRate(ctx context.Context, id int64) ([]Heartrate, error) {
	rows, err := q.db.Query(ctx, getHeartRate, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Heartrate{}
	for rows.Next() {
		var i Heartrate
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.High,
			&i.Low,
			&i.Average,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartRateByDate = `-- name: GetHeartRateByDate :many
SELECT id, date, high, low, average, created_timestamp, updated_timestamp
FROM heartrate
WHERE date = $1
`

func (q *Queries) GetHeartRateByDate(ctx context.Context, date time.Time) ([]Heartrate, error) {
	rows, err := q.db.Query(ctx, getHeartRateByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Heartrate{}
	for rows.Next() {
		var i Heartrate
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.High,
			&i.Low,
			&i.Average,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getHeartRates = `-- name: GetHeartRates :many
SELECT id, date, high, low, average, created_timestamp, updated_timestamp
FROM heartrate
ORDER BY date DESC
LIMIT $2 OFFSET $1
`

type GetHeartRatesParams struct {
	RowOffset int32 `json:"row_offset"`
	RowLimit  int32 `json:"row_limit"`
}

func (q *Queries) GetHeartRates(ctx context.Context, arg GetHeartRatesParams) ([]Heartrate, error) {
	rows, err := q.db.Query(ctx, getHeartRates, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Heartrate{}
	for rows.Next() {
		var i Heartrate
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.High,
			&i.Low,
			&i.Average,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadyScore = `-- name: GetReadyScore :many
SELECT id, date, score, created_timestamp, updated_timestamp
FROM readyscore
WHERE id = $1
`

func (q *Queries) GetReadyScore(ctx context.Context, id int64) ([]Readyscore, error) {
	rows, err := q.db.Query(ctx, getReadyScore, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Readyscore{}
	for rows.Next() {
		var i Readyscore
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Score,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadyScoreByDate = `-- name: GetReadyScoreByDate :many
SELECT id, date, score, created_timestamp, updated_timestamp
FROM readyscore
WHERE date = $1
`

func (q *Queries) GetReadyScoreByDate(ctx context.Context, date time.Time) ([]Readyscore, error) {
	rows, err := q.db.Query(ctx, getReadyScoreByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Readyscore{}
	for rows.Next() {
		var i Readyscore
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Score,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getReadyScores = `-- name: GetReadyScores :many
SELECT id, date, score, created_timestamp, updated_timestamp
FROM readyscore
ORDER BY date DESC
LIMIT $2 OFFSET $1
`

type GetReadyScoresParams struct {
	RowOffset int32 `json:"row_offset"`
	RowLimit  int32 `json:"row_limit"`
}

func (q *Queries) GetReadyScores(ctx context.Context, arg GetReadyScoresParams) ([]Readyscore, error) {
	rows, err := q.db.Query(ctx, getReadyScores, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Readyscore{}
	for rows.Next() {
		var i Readyscore
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Score,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleep = `-- name: GetSleep :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp
FROM sleep
WHERE id = $1
`

func (q *Queries) GetSleep(ctx context.Context, id int64) ([]Sleep, error) {
	rows, err := q.db.Query(ctx, getSleep, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepByDate = `-- name: GetSleepByDate :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp
FROM sleep
WHERE date = $1
`

func (q *Queries) GetSleepByDate(ctx context.Context, date time.Time) ([]Sleep, error) {
	rows, err := q.db.Query(ctx, getSleepByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleeps = `-- name: GetSleeps :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp
FROM sleep
ORDER BY date DESC
LIMIT $2 OFFSET $1
`

type GetSleepsParams struct {
	RowOffset int32 `json:"row_offset"`
	RowLimit  int32 `json:"row_limit"`
}

func (q *Queries) GetSleeps(ctx context.Context, arg GetSleepsParams) ([]Sleep, error) {
	rows, err := q.db.Query(ctx, getSleeps, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpo2 = `-- name: GetSpo2 :many
SELECT id, date, average_spo2, created_timestamp, updated_timestamp
FROM spo2
WHERE id = $1
`

func (q *Queries) GetSpo2(ctx context.Context, id int64) ([]Spo2, error) {
	rows, err := q.db.Query(ctx, getSpo2, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spo2{}
	for rows.Next() {
		var i Spo2
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.AverageSpo2,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpo2ByDate = `-- name: GetSpo2ByDate :many
SELECT id, date, average_spo2, created_timestamp, updated_timestamp
FROM spo2
WHERE date = $1
`

func (q *Queries) GetSpo2ByDate(ctx context.Context, date time.Time) ([]Spo2, error) {
	rows, err := q.db.Query(ctx, getSpo2ByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spo2{}
	for rows.Next() {
		var i Spo2
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.AverageSpo2,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSpo2s = `-- name: GetSpo2s :many
SELECT id, date, average_spo2, created_timestamp, updated_timestamp
FROM spo2
ORDER BY date DESC
LIMIT $2 OFFSET $1
`

type GetSpo2sParams struct {
	RowOffset int32 `json:"row_offset"`
	RowLimit  int32 `json:"row_limit"`
}

func (q *Queries) GetSpo2s(ctx context.Context, arg GetSpo2sParams) ([]Spo2, error) {
	rows, err := q.db.Query(ctx, getSpo2s, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Spo2{}
	for rows.Next() {
		var i Spo2
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.AverageSpo2,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStress = `-- name: GetStress :many
SELECT id, date, high_stress_duration, created_timestamp, updated_timestamp
FROM stress
WHERE id = $1
`

func (q *Queries) GetStress(ctx context.Context, id int64) ([]Stress, error) {
	rows, err := q.db.Query(ctx, getStress, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stress{}
	for rows.Next() {
		var i Stress
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.HighStressDuration,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStressByDate = `-- name: GetStressByDate :many
SELECT id, date, high_stress_duration, created_timestamp, updated_timestamp
FROM stress
WHERE date = $1
`

func (q *Queries) GetStressByDate(ctx context.Context, date time.Time) ([]Stress, error) {
	rows, err := q.db.Query(ctx, getStressByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stress{}
	for rows.Next() {
		var i Stress
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.HighStressDuration,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStresses = `-- name: GetStresses :many
SELECT id, date, high_stress_duration, created_timestamp, updated_timestamp
FROM stress
ORDER BY date DESC
LIMIT $2 OFFSET $1
`

type GetStressesParams struct {
	RowOffset int32 `json:"row_offset"`
	RowLimit  int32 `json:"row_limit"`
}

func (q *Queries) GetStresses(ctx context.Context, arg GetStressesParams) ([]Stress, error) {
	rows, err := q.db.Query(ctx, getStresses, arg.RowOffset, arg.RowLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Stress{}
	for rows.Next() {
		var i Stress
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.HighStressDuration,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveHeartRate = `-- name: SaveHeartRate :exec
INSERT INTO heartrate (date, low, high, average) VALUES ($1, $2, $3, $4) ON CONFLICT (date) DO UPDATE SET low = EXCLUDED.low, high = EXCLUDED.high, average = EXCLUDED.average
`

type SaveHeartRateParams struct {
	Date    time.Time `json:"date"`
	Low     int       `json:"low"`
	High    int       `json:"high"`
	Average int       `json:"average"`
}

func (q *Queries) SaveHeartRate(ctx context.Context, arg SaveHeartRateParams) error {
	_, err := q.db.Exec(ctx, saveHeartRate,
		arg.Date,
		arg.Low,
		arg.High,
		arg.Average,
	)
	return err
}

const saveReadyScore = `-- name: SaveReadyScore :exec
INSERT INTO readyscore (date, score) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET score = EXCLUDED.score
`

type SaveReadyScoreParams struct {
	Date  time.Time `json:"date"`
	Score int       `json:"score"`
}

func (q *Queries) SaveReadyScore(ctx context.Context, arg SaveReadyScoreParams) error {
	_, err := q.db.Exec(ctx, saveReadyScore, arg.Date, arg.Score)
	return err
}

const saveSleep = `-- name: SaveSleep :exec
INSERT INTO sleep (date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (date) DO UPDATE SET total_sleep = EXCLUDED.total_sleep, rating = EXCLUDED.rating, light_sleep = EXCLUDED.light_sleep, deep_sleep = EXCLUDED.deep_sleep, rem_sleep = EXCLUDED.rem_sleep
`

type SaveSleepParams struct {
	Date       time.Time `json:"date"`
	Rating     int64     `json:"rating"`
	TotalSleep int       `json:"total_sleep"`
	DeepSleep  int       `json:"deep_sleep"`
	LightSleep int       `json:"light_sleep"`
	RemSleep   int       `json:"rem_sleep"`
}

func (q *Queries) SaveSleep(ctx context.Context, arg SaveSleepParams) error {
	_, err := q.db.Exec(ctx, saveSleep,
		arg.Date,
		arg.Rating,
		arg.TotalSleep,
		arg.DeepSleep,
		arg.LightSleep,
		arg.RemSleep,
	)
	return err
}

const saveSpo2 = `-- name: SaveSpo2 :exec
INSERT INTO spo2 (date, average_spo2) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET average_spo2 = EXCLUDED.average_spo2
`

type SaveSpo2Params struct {
	Date        time.Time `json:"date"`
	AverageSpo2 float64   `json:"average_spo2"`
}

func (q *Queries) SaveSpo2(ctx context.Context, arg SaveSpo2Params) error {
	_, err := q.db.Exec(ctx, saveSpo2, arg.Date, arg.AverageSpo2)
	return err
}

const saveStress = `-- name: SaveStress :exec
INSERT INTO stress (date, high_stress_duration) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET high_stress_duration = EXCLUDED.high_stress_duration
`

type SaveStressParams struct {
	Date               time.Time `json:"date"`
	HighStressDuration int       `json:"high_stress_duration"`
}

func (q *Queries) SaveStress(ctx context.Context, arg SaveStressParams) error {
	_, err := q.db.Exec(ctx, saveStress, arg.Date, arg.HighStressDuration)
	return err
}
