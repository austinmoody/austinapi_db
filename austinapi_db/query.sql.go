// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package austinapi_db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const getSleep = `-- name: GetSleep :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp FROM sleep WHERE id = $1
`

func (q *Queries) GetSleep(ctx context.Context, id uuid.UUID) ([]Sleep, error) {
	rows, err := q.db.Query(ctx, getSleep, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepByDate = `-- name: GetSleepByDate :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp FROM sleep WHERE date = $1
`

func (q *Queries) GetSleepByDate(ctx context.Context, date time.Time) ([]Sleep, error) {
	rows, err := q.db.Query(ctx, getSleepByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Sleep{}
	for rows.Next() {
		var i Sleep
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSleepDateById = `-- name: GetSleepDateById :many
SELECT date FROM sleep WHERE id = $1
`

func (q *Queries) GetSleepDateById(ctx context.Context, id uuid.UUID) ([]time.Time, error) {
	rows, err := q.db.Query(ctx, getSleepDateById, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []time.Time{}
	for rows.Next() {
		var date time.Time
		if err := rows.Scan(&date); err != nil {
			return nil, err
		}
		items = append(items, date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSleep = `-- name: ListSleep :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp, previous_id, next_id FROM (
    SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp,
           CAST(LAG(id) OVER (ORDER BY date DESC) AS UUID)  AS previous_id,
           CAST(LEAD(id) OVER (ORDER BY date DESC) AS UUID) AS next_id
    FROM sleep
) sleeps
ORDER BY date DESC
LIMIT $1
`

type ListSleepRow struct {
	ID               uuid.UUID
	Date             time.Time
	Rating           int64
	TotalSleep       int
	DeepSleep        int
	LightSleep       int
	RemSleep         int
	CreatedTimestamp time.Time
	UpdatedTimestamp time.Time
	PreviousID       uuid.UUID
	NextID           uuid.UUID
}

func (q *Queries) ListSleep(ctx context.Context, limit int32) ([]ListSleepRow, error) {
	rows, err := q.db.Query(ctx, listSleep, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSleepRow{}
	for rows.Next() {
		var i ListSleepRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
			&i.PreviousID,
			&i.NextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSleepNext = `-- name: ListSleepNext :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp, previous_id, next_id FROM (
      SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp,
             CAST(LAG(id) OVER (ORDER BY date DESC) AS UUID)  AS previous_id,
             CAST(LEAD(id) OVER (ORDER BY date DESC) AS UUID) AS next_id
      FROM sleep
              ) sleeps
WHERE date <= (
    SELECT date FROM sleep AS SLP WHERE SLP.id = $1
)
ORDER BY date DESC
LIMIT $2
`

type ListSleepNextParams struct {
	ID    uuid.UUID
	Limit int32
}

type ListSleepNextRow struct {
	ID               uuid.UUID
	Date             time.Time
	Rating           int64
	TotalSleep       int
	DeepSleep        int
	LightSleep       int
	RemSleep         int
	CreatedTimestamp time.Time
	UpdatedTimestamp time.Time
	PreviousID       uuid.UUID
	NextID           uuid.UUID
}

func (q *Queries) ListSleepNext(ctx context.Context, arg ListSleepNextParams) ([]ListSleepNextRow, error) {
	rows, err := q.db.Query(ctx, listSleepNext, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSleepNextRow{}
	for rows.Next() {
		var i ListSleepNextRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
			&i.PreviousID,
			&i.NextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSleepPrevious = `-- name: ListSleepPrevious :many
SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp, previous_id, next_id FROM (
      SELECT id, date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep, created_timestamp, updated_timestamp,
             CAST(LAG(id) OVER (ORDER BY date DESC) AS UUID)  AS previous_id,
             CAST(LEAD(id) OVER (ORDER BY date DESC) AS UUID) AS next_id
      FROM sleep
              ) sleeps
WHERE date >= (
    SELECT date FROM sleep AS SLP WHERE SLP.id = $1
)
ORDER BY date DESC
LIMIT $2
`

type ListSleepPreviousParams struct {
	ID    uuid.UUID
	Limit int32
}

type ListSleepPreviousRow struct {
	ID               uuid.UUID
	Date             time.Time
	Rating           int64
	TotalSleep       int
	DeepSleep        int
	LightSleep       int
	RemSleep         int
	CreatedTimestamp time.Time
	UpdatedTimestamp time.Time
	PreviousID       uuid.UUID
	NextID           uuid.UUID
}

func (q *Queries) ListSleepPrevious(ctx context.Context, arg ListSleepPreviousParams) ([]ListSleepPreviousRow, error) {
	rows, err := q.db.Query(ctx, listSleepPrevious, arg.ID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSleepPreviousRow{}
	for rows.Next() {
		var i ListSleepPreviousRow
		if err := rows.Scan(
			&i.ID,
			&i.Date,
			&i.Rating,
			&i.TotalSleep,
			&i.DeepSleep,
			&i.LightSleep,
			&i.RemSleep,
			&i.CreatedTimestamp,
			&i.UpdatedTimestamp,
			&i.PreviousID,
			&i.NextID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveHeartRate = `-- name: SaveHeartRate :exec
INSERT INTO heartrate (date, low, high, average) VALUES ($1, $2, $3, $4) ON CONFLICT (date) DO UPDATE SET low = EXCLUDED.low, high = EXCLUDED.high, average = EXCLUDED.average
`

type SaveHeartRateParams struct {
	Date    time.Time
	Low     int
	High    int
	Average int
}

func (q *Queries) SaveHeartRate(ctx context.Context, arg SaveHeartRateParams) error {
	_, err := q.db.Exec(ctx, saveHeartRate,
		arg.Date,
		arg.Low,
		arg.High,
		arg.Average,
	)
	return err
}

const savePreparedness = `-- name: SavePreparedness :exec
INSERT INTO preparedness (date, rating) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET rating = EXCLUDED.rating
`

type SavePreparednessParams struct {
	Date   time.Time
	Rating int
}

func (q *Queries) SavePreparedness(ctx context.Context, arg SavePreparednessParams) error {
	_, err := q.db.Exec(ctx, savePreparedness, arg.Date, arg.Rating)
	return err
}

const saveSleep = `-- name: SaveSleep :exec
INSERT INTO sleep (date, rating, total_sleep, deep_sleep, light_sleep, rem_sleep) VALUES ($1, $2, $3, $4, $5, $6) ON CONFLICT (date) DO UPDATE SET total_sleep = EXCLUDED.total_sleep, rating = EXCLUDED.rating, light_sleep = EXCLUDED.light_sleep, deep_sleep = EXCLUDED.deep_sleep, rem_sleep = EXCLUDED.rem_sleep
`

type SaveSleepParams struct {
	Date       time.Time
	Rating     int64
	TotalSleep int
	DeepSleep  int
	LightSleep int
	RemSleep   int
}

func (q *Queries) SaveSleep(ctx context.Context, arg SaveSleepParams) error {
	_, err := q.db.Exec(ctx, saveSleep,
		arg.Date,
		arg.Rating,
		arg.TotalSleep,
		arg.DeepSleep,
		arg.LightSleep,
		arg.RemSleep,
	)
	return err
}

const saveSpo2 = `-- name: SaveSpo2 :exec
INSERT INTO spo2 (date, average_spo2) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET average_spo2 = EXCLUDED.average_spo2
`

type SaveSpo2Params struct {
	Date        time.Time
	AverageSpo2 float64
}

func (q *Queries) SaveSpo2(ctx context.Context, arg SaveSpo2Params) error {
	_, err := q.db.Exec(ctx, saveSpo2, arg.Date, arg.AverageSpo2)
	return err
}

const saveStress = `-- name: SaveStress :exec
INSERT INTO stress (date, high_stress_duration) VALUES ($1, $2) ON CONFLICT (date) DO UPDATE SET high_stress_duration = EXCLUDED.high_stress_duration
`

type SaveStressParams struct {
	Date               time.Time
	HighStressDuration int
}

func (q *Queries) SaveStress(ctx context.Context, arg SaveStressParams) error {
	_, err := q.db.Exec(ctx, saveStress, arg.Date, arg.HighStressDuration)
	return err
}
